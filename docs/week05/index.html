<!-- uses https://highlightjs.org/
-->

<html>

<head>
	<link rel="shortcut icon" href="https://byui-cse.github.io/Language-Courses/site/images/fav.ico" type="image/x-i        con">
        <script type="text/javascript">
                 var codeType = "C++"
        </script>
        <script src="https://byui-cse.github.io/Language-Courses/site/highlight.pack.js"></script>
        <link rel="stylesheet" href="https://byui-cse.github.io/Language-Courses/site/highlight_styles/xcode.css">
        <link rel="stylesheet" href="https://byui-cse.github.io/Language-Courses/site/weekly.css">
        <script type="text/javascript" src="https://byui-cse.github.io/Language-Courses/site/weekly.js"></script>
	

</head>

<body onload="fetchSource()">
<div class="hero-image">
  <div class="hero-text">
    <h1>CSE 121c: Week 05</h1>
    <p>Controlling Your Code</p>
  </div>
</div>
	<h1>Choice Making and Computational Flow</h1>
	<h3>Logic Used in Computing</h3>
	<p>Since our computers use a binary system, it is logical that the type of logic used when writing code is also binary. In other words, the logic
		used when writing C includes only two possibilities when checking for truth. Those two options are true or false. Don't be fooled. There are other types of logic used in computing and in other programming languages. An example where you would use a logic that has more than pure true and pure false as options is when you write code or create hardware to do signal processing.
	</p>
	<p>As novice computer people, we think of the electrical signal coming through a wire, be it internal or external to the computer, as being either on or 
		off coresponding to a 1 or a zero with the signal looking something like this.</p>
	<img src="https://cdn.instructables.com/FE7/OVFQ/J4G58M8L/FE7OVFQJ4G58M8L.LARGE.jpg?auto=webp&fit=bounds"/>
	<p>While we may think of the signal this way, it is not actually like this at all. Why? Because it is too dificult to get a signal to be 
		truely off. The noise in the wire caused by electromagnetic induction makes it nearly impossible to have a completly 'off' signal. 
		Instead, there would be a 'nearly off' signal and a design decision would have to be made by the engineers as to how strong an  the 'on' signal would have to be to 
		indicate an actual on. This get's very nasty, since electromagnetic interference can also degrade a fully on signal so it would be 'nearly off'.  
	</p>
	<p>How then, does signal processing work? How do electrical signals get sent down a wire inside a computer or across a network? The trick is to NOT use on and off. 
		Instead, electrical signal voltages are either positive (+) or negative (-), not neutral (off).</p>
	<img src="https://www.researchgate.net/profile/Mohamed_Salem47/publication/295276491/figure/fig8/AS:668240233639951@1536332295896/The-inverter-output-voltage-square-wave_W640.jpg"/>
	<p>When using this +/- type system, the amplitude (height) of the wave is irelevent...only 
		whether current signal sample is negative or positive. If you want to know more about this, a good place to start would be 
		to do a web search for 'convert analog digital signal'. You'll start on an interesting journey.</p>
    <p>Electronic signal processing uses a logic with  
		<a href="https://en.wikipedia.org/wiki/Many-valued_logic">many different kinds of true or false values</a>. 
		Do not get caught up in the idea that for something to be logical there can only be one true and one false. If you do, you will limit yourself. 
		A simple three valued logic, used in computer databases and elsewhere, has three possible values of true, false, and undefined. 
	</p>
	

	<h3>If and Switch</h3>

	<p>The C language uses two value logic. Zero is false and anything that is not zero is true. This means you could write some code that looks something 
	like this.</p>
	<p><pre><code class="C++">int isTrue = 1;
if(isTrue){
    printf("It's true! :) \n");
}
else{
    printf("It's false :( \n");
}
</code>
<p>Notice that the conditional check is put between the ( and ) characters and that the code to be executed for each condition is put between the { and 
	} characters for each condition.
	</p>
	</pre></p>
	<p>Often, but not always, it is inconvinent to think if conditions using numbers rather than true or false. Because of this, there is a header file that defines true and 
	false for you. All it really does is define a new bool type that's really an int, and a true that has a value of 1 and a false that has a value of 0. 
	So...not much of a change, but after including 
	<a href="https://gist.github.com/duckinator/303856">stdbool.h</a> your code can now look like this.</p>
	<p><pre><code class="C++">bool isTrue = false;
if(isTrue){
    printf("It's true! :) \n");
}
else{
    printf("It's false :( \n");
}
</code>
	</pre></p>
	<p>If you go back and look at the operators in the <a href="../week01/index.html"> reading for week 01</a>, you will find all of the boolean 
	operators you are used to using when determining the truth or falsehood of a logic statement. There are also a large number of C tutorials for 
	learning how to do <a href="https://www.khanacademy.org/computing/ap-computer-science-principles/programming-101/boolean-logic/a/compound-booleans-with-logical-operators">
	compound boolean checks</a> like you see in many other languages.</p>

	<p>But what if there are more than two possible situations you want to react to? Ahhhh....that's where else if comes in. Here is an example of 
	making poor nutrition choices.</p>
	<p><pre><code class="C++">if(cashOnHand > 3 && cashOnHand < 10){
        printf("Buy rammen noodles.\n");
    }
    else if(cashOnHand <= 20){
        printf("Buy a frozen pizza.\n");
    }
    else{
        printf("Go out to eat.\n");
    }
}
</code>
	</pre></p>

	<p>Sometimes an if statement, with all its conditions, possibilities, and ifs embeded inside of other ifs, can become too hard to read and consider.
		Like many other languages, but not Python, C has an alternative to using if statements that can help solve this reading and cognition problem, 
		the <a href="https://en.cppreference.com/w/c/language/switch">switch statement</a>. 
		Switch statements allow you to branch which part of your code executes, as an if statement does, but on a format that, sometimes, is easier to read. 
		Here is a very simplified example.
	</p>
		<p><pre><code class="C++">int cashOnHand;
scanf("%d",&cashOnHand);
switch (cashOnHand) {
    case 5:
        printf("not much\n");
        break;
    case 10:
        printf("a little more\n");
        break;
    default:
        printf("unacceptable number\n");
        break;
}
</code>
	</pre></p> 
	<p>There are some important parts of switches that you MUST both be aware of and know. First, there is the call to switch. You must pass it a value. 
		In C speak, we say we are 'switching on' the value, but not in the sense of switching on a light bulb. When we say we are switching 
		on something, it means that is the thing we are going to examine for specific values. It would be like saying we would be 'ifing on' a value 
		or set of values if we were using an if statement.
	</p>
	<p>Another important thing to remember is that in C, but not in all languages that have the concept of a switch statement, the type of things 
		you can switch on are very limited. You can switch on an ints, shorts, longs, and you can switch on a character 
		(which by the way is an int in C), or an enum (which is also an int in C). 
		<a href="https://www.geeksforgeeks.org/interesting-facts-about-switch-statement-in-c/">That's it. That's all</a>.
		You can not switch on booleans, structures, or anything else since they are not integral types of values. If something is an ntegeral type of 
		value, it means it is numeric but isn't a floating point type or fixed point type like 2.5.
	</p>
	<p>Another thing to be aware of is how the <a href="https://beginnersbook.com/2017/08/cpp-switch-case/">break keyword</a> works. 
		You leave it out when you want the code for consecutive cases to execute and put it in when you don't. A common noob mistake is to accidentally 
		leave out a break when they intended to put one in. If you see your code executing statements from more than one case and you didn't intend 
		for that to happen, you left out a break. Go fix the bug by adding one in.
	</p>

	<h3>Getting Loopy</h3>
	<p>Conditional branching has a cousin...loops. If you think about loops for a bit you'll realize they continue under certain conditions. That means 
		loops are also a type of conditional branching. There are <a href="https://www.geeksforgeeks.org/loops-in-c-and-cpp/"> three types of loops</a> 
		in C, the for loop, the while loop, and the do-while loop. Each has a purpose so let's take a look at each type.
	</p>
	<h4>The For Loop</h4>
	<p>For loops are used to iterate over arrays. That is their purpose. If you are trying to use a for loop for any other purpose, you picked the 
		wrong loop type.
	</p>
    <p>Let's start off with an extremely simple situation where all you need to do is print out each item in an array of items. This example does nothing but print out each integer on its own line in the 
    console.</p>
	<p><pre><code class="C++">int marks[] = {4,5,6};
for(int i = 0; i < 3; i++){
    printf("%d",marks[i]);
}
</code>
	</pre></p> 
    <p>The C for loop has four parts. The first three are seperated by the ; character. The first part is an int variable that is used to keep 
    	track of where we are in the array. By tradition the name of this variable is 'i' and stands for iterator. We are, after all, 
    	<a href="https://dictionary.cambridge.org/us/dictionary/english/iterate"> iterating</a> over an array. As you can see in the code 
    above, the int variable i is initially set to be 0. The next part is the continuation check. In the code above it is 'i &lt 3'. 
	This means that when i is greater than or equal to 3, the loop will terminate.</p>
    <p>The third part is 'i++'. This is the part of the code that updates the iterator so the loop will move through the array. The fourth 
    part of the for loop is the code to execute each time i is less than 3. This code is between the { and } characters just like with the if 
	statement you saw earlier.</p>
    <p>It is important to understand the timing when each of these parts is executed so let me step you through it.</p>
    <p>As the code is run, the first time the for loop is executed, i is set to zero and then i is checked to make sure it is less than 3. 
    If it is less than three the code in between the { and } is executed. When the code reaches the } character, execution returns to the line 
	including the 'for' declaration. This time, i is not set to 0. Instead, i++ is executed and the i &lt 3 check is done again. If i is still 
	less than 3, the code in the fourth part is executed again. If not, the line of code AFTER the } character is executed since the loop is done.</p>




    <p>While there is no built-in filter, map, or reduce functions in C, you can still do these things, but you will have to write code to do this 
    yourself. Below is a naive example of how you could filter an array of integers so you end up with just evens in a new array called foundEvens.</p>

<p><pre><code class="C++">int marks[] = {4,5,6,10,13,21,44};
int evenMarks[7];
int foundEvens = 0;
for(int i = 0; i < 7; i++){
    int aMark = marks[i];
    if (aMark % 2 == 0) {
        evenMarks[foundEvens] = aMark;
        foundEvens++;
    }
}
</code>
	</pre></p>
    <p>Can you also map an array? You bet. In the example below all of the elements in the array are updated to be twice what they were before.</p>
<p><pre><code class="C++">int marks[] = {4,5,6,10,13,21,44};
int evenMarks[7];
int foundEvens = 0;
for(int i = 0; i < 7; i++){
    int aMark = marks[i];
    if (aMark % 2 == 0) {
        evenMarks[foundEvens] = aMark;
        foundEvens++;
    }
}
</code>
	</pre></p>
    <p>If you want to reduce an array to one sensible value, you can do that to.</p>
    <p><pre><code class="C++">int marks[] = {4,5,6,10,13,21,44};
int sum = 0;
for(int i = 0; i < 7; i++){
    sum += marks[i];
}
</code>
	</pre></p>
    <p>So you can do map, filter, and reduce in C, but you have to write them yourself or find a non-standard library someone else has written and use that.</p>
	<h4>The While Loop</h4>
	<p>
		While loops are used to keep executing the same code over and over again as long as some state remains the same. For example, as long as 
		the user hasn't selected an appropriate option, keep asking them for an option.
	</p>

	<p><pre><code class="C++">int numAttendies = 0;
while (numAttendies < 100) {
    printf("100 attendies are required to have this meeting. You currently have %d.", numAttendies);
    int moreAttendies;
    scanf("Enter the number of additional attendies you've found: %d",&moreAttendies);
    numAttendies += moreAttendies;
}
</code>
	</pre></p> 
	<h4>The Do-While Loop</h4>
	<p>
		Do-while loops are like while loops in that they execute the same code repeatedly as long as some state remains the same. However, and this 
		is a BIG however, they are dangerous. They execute the loop code BEFORE the condition is checked. This is kind of like running around with 
		a blind flold on when you know there is a cliff nearby. For most of the steps you take you won't die. But there is that one step..... 
	</p>
	<p>
		In the 21 years I, the author, have been writing code, there is only one time where I had to use a do-while loop, and that was because of a 
		poor engineering choice someone else made elsewhere in the code base I was working on...an engineering choice I wasn't allowed change. All of the other times 
		where a do-while might have been used, I was able to rethink the situation and find a small change that would make it possible to use a 
		while loop instead. Here is a well thought out comment regarding do-while loops in a <a href="https://www.reddit.com/r/learnprogramming/comments/93gka0/why_dont_we_see_more_use_of_the_dowhile_loop/">redit</a> on the topic.</p>
	<blockquote>The problem with do while is that it is syntactically unlike any other language construct in a confusing and ugly way.
In every other case where a code block is conditional (if, for, while, else if), the condition being evaluated is read before the block it controls. When the reader hits an if statement, they know under what circumstances the enclosed code executes. Same for while.
When a reader hits a do while block, they have no idea how long the enclosed code will execute. They have to scroll down to the bottom of the loop and check, then they can go back and read the code. This context switch is expensive for the reader. Scrolling around for no reason is annoying. Having code in a place you don't expect is annoying.
Every time you write a do while loop, you should instead not do that and express it as a while loop. They're much clearer and lead to cleaner code.</blockquote>

	<p>So here is what a do-while loop looks like in C.
	</p>

	<p><pre><code class="C++">int choice;
do {
    printf("How many loop types do you think there are in C?");
    scanf("%d",&choice);
} while (choice != 3);
</code>
	</pre></p> 
<p>And here is a while loop that would do the same thing.</p>
	<p><pre><code class="C++">int choice = 0;
while (choice != 3) {
    printf("How many loop types do you think there are in C?");
    scanf("%d",&choice);
}
</code>
	</pre></p>

<a rel="license" href="http://creativecommons.org/licenses/by/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by/4.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.
</body>
</html>
